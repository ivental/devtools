### Devtools Project


[![Java CI with Checkstyle and JaCoCo](https://github.com/ivental/devtools/actions/workflows/ci.yml/badge.svg)](https://github.com/ivental/devtools/actions/workflows/ci.yml)



## Code Review Checklist

Используйте этот чеклист для само-ревью перед запросом ревью у ментора:

### Функциональность
- [ ] Код решает поставленную задачу полностью
- [ ] Обработаны граничные случаи (null, пустые данные, экстремальные значения)
- [ ] Обработка ошибок реализована корректно

### Тесты
- [ ] Добавлены тесты для нового функционала (или обновлены существующие)
- [ ] Все тесты проходят локально: `./gradlew test`
- [ ] Покрыты позитивные и негативные сценарии
- [ ] JaCoCo coverage ≥ 80% для нового кода

### Читаемость и стиль
- [ ] Имена переменных, методов и классов отражают назначение
- [ ] Нет дублирования кода (DRY principle)
- [ ] Checkstyle проходит без ошибок: `./gradlew checkstyleMain`
- [ ] Нет закомментированного кода или отладочного вывода (`System.out.println`)

### Документация
- [ ] README обновлён (если добавлена новая функциональность)
- [ ] Публичные методы имеют JavaDoc (если применимо)
- [ ] Примеры использования актуальны
- [ ] Runbook обновлён (если изменились команды запуска/проверки)

### Производительность и безопасность
- [ ] Нет очевидных проблем производительности
- [ ] Нет хардкода паролей, токенов или конфиденциальных данных

## Примеры Code Review комментариев

### Хорошие комментарии (конструктивные)

**Пример 1:**

**Проблема:** Метод `calculateDiscount` (строка 45) имеет 3 вложенных if-else и 40 строк.
**Почему это важно:** Сложная логика плохо тестируется и тяжело поддерживается.
**Предложение:** Вынести каждое условие в отдельный метод (например, `isEligibleForBonusDiscount()`)
и использовать паттерн Strategy для разных типов скидок.



**Пример 2:**

**Проблема:** Тест `testProcessOrder` (строка 78) проверяет только успешный сценарий.
**Почему это важно:** Не проверена обработка ошибок при недостаточном балансе.
**Предложение:** Добавить тест `testProcessOrder_InsufficientBalance_ThrowsException()`
с использованием `assertThatThrownBy()`.



### Плохие комментарии (неконструктивные)

**Пример 1:**

Этот код ужасен, полностью переписать.


**Почему плохо:** Нет конкретики (что именно плохо), нет предложения (как исправить),
токсичный тон (демотивирует автора).

**Пример 2:**

Здесь лучше использовать Stream API.


**Почему плохо:** Нет объяснения почему лучше, нет примера как переписать,
неясно какую проблему это решает.
## Результат само-ревью

#### 1. Забыт отладочный вывод
**Файл:** src/main/java/ru/mentee/power/devtools/Student.java (строка 19)
**Проблема:** Оставлен `System.out.println("Debug: starting loop")`
**Почему важно:** Отладочный вывод замусоривает логи production-приложения и создаёт впечатление небрежности.
**Исправление:** Удалить строку или заменить на logger (если логирование настроено).

#### 3. Закомментированный код
**Файл:** src/main/java/ru/mentee/power/devtools/Student.java (строки 9-11)
**Проблема:** Закомментированы 3 строки метода, забыл раскоментировать.
**Почему важно:** Закомментированный код создаёт путаницу: непонятно зачем он сохранён и актуален ли.
Если нужна история изменений — она в Git.
**Исправление:** Удалить закомментированный код. Если нужна старая версия — посмотреть в Git History.

## Информационный поиск — результаты DVT-11
### Запросы и источники
| № | Запрос                                | Операторы                                                         | Официальный источник                                                                                                               | Альтернатива                                                                                                     | Статус | Дата проверки |
|---|---------------------------------------|-------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------|--------|---------------|
| 1 | Lombok в Maven Central (Gradle Short) | site:search.maven.org "lombok" OR site:mvnrepository.com "lombok" | https://central.sonatype.com/artifact/org.projectlombok/lombok/1.18.30/overview                                                    | https://mvnrepository.com/artifact/org.projectlombok/lombok/1.18.30                                              | 200 OK | 23.12.2025    |
| 2 | Java Stream API документация          | site:docs.oracle.com "stream api" intitle:api java 21             | https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/stream/Stream.html?spm=a2ty_o01.29997173.0.0.19a25171adJLY2 | https://docs.oracle.com/en/middleware/standalone/coherence/15.1.1/develop-applications/using-repository-api.html | 200 OK | 23.12.2025    |
| 3 | горячие клавиши IntelliJ IDEA         | site:www.jetbrains.com/help "keymap" "intellij idea"              | https://www.jetbrains.com/help/idea/settings-keymap.html                                                                           | https://tproger.ru/digest/ide-hotkeys                                                                            | 200 OK | 23.12.2025    |

### AI-промпты и сравнение ассистентов

#### Промпт 1: План решения
**Задача**: Нужно добавить валидацию email в класс Student  
**Контекст**: Java 25, у меня есть класс Student с полем email (String), проект на Gradle  
**Ограничения**: без использования регулярных выражений на данном этапе, простая проверка наличия @ и точки  
**Что мне нужно от тебя**: план из 3-5 шагов, объяснение "почему именно так", НЕ пиши код — я реализую сам  
**Критерии успеха**: валидация отклоняет пустые строки, строки без @, строки без точки после @  

**AI-1 [deepseek](https://chat.deepseek.com/):**  
План шагов
Определение места для валидации. Создать приватный метод валидации (например, validateEmail(String email)) внутри класса Student. Это обеспечит инкапсуляцию: логика проверки email будет скрыта внутри класса и может быть легко изменена в будущем. Валидацию следует проводить непосредственно перед тем, как email присваивается полю объекта (в сеттере или конструкторе).
Проверка на null и пустую строку. В начале метода validateEmail добавить проверку: если строка равна null или после обрезки пробелов (trim()) она пустая, — выбрасывать исключение (например, IllegalArgumentException). Это соответствует требованию отклонять пустые строки и предотвращает NullPointerException на следующих шагах. Почему trim()? Потому что " " или " user@domain.com " — это практически пустая или некорректно оформленная строка.
Проверка наличия символа '@'. Использовать метод String.indexOf('@'). Если результат равен -1 (символ не найден), выбрасывать исключение. Это самая базовая и обязательная часть синтаксиса email-адреса.
Проверка наличия точки после '@'. Это ключевой шаг, который отличает простую проверку от наивной. Нужно убедиться, что после символа @ в строке есть как минимум одна точка (.). Алгоритм:
Найти индекс символа @ (из шага 3).
Используя метод String.substring(index), получить подстроку, которая начинается после символа @.
В этой подстроке проверить наличие точки с помощью indexOf('.'). Если точка не найдена, значит, в доменной части адреса её нет, и это невалидный email. Почему именно после '@'? Потому что локальная часть адреса (до @) может содержать точки, но для домена (например, domain.com) точка обязательна. Проверка "user.@domain" без этого уточнения пройдёт, хотя является сомнительной.
Интеграция валидации в публичный API класса. Вызвать метод validateEmail:
В сеттере поля email (setEmail): это гарантирует, что любой email, устанавливаемый через сеттер, будет проверен.
В конструкторе(ах) класса, которые принимают email как параметр. Это обеспечит, что объект Student не может быть создан с некорректным email.
Почему в обоих местах? Для сохранения консистентности объекта. Независимо от того, создаётся ли объект или изменяется позже, его поле email всегда будет проходить одну и ту же проверку.
Почему этот план эффективен?
Соответствует ограничениям: Использует только методы String (indexOf, substring, trim), без регулярных выражений.
Выполняет критерии: Корректно отклоняет пустые строки, строки без @ и, что важно, строки, где точка находится только до @ (например, user.@domain или user@domain).
Гибкий и поддерживаемый: Валидация вынесена в отдельный метод. Если в будущем требования усложнятся (добавится проверка на пробелы, длина домена и т.д.), нужно будет изменить только этот метод.
Безопасный: Проверка начинается с null и пустых значений, что предотвращает сбои.
Чётко сообщает об ошибке: Использование IllegalArgumentException с понятным сообщением (например, "Email must not be empty", "Email must contain '@'", "Email must contain a dot in the domain part after '@'") сразу укажет пользователю API на причину проблемы.
Этот план даст вам надёжную базовую валидацию, которую вы сможете легко реализовать и при необходимости расширить.

**AI-2 [chatGPT](https://chatgpt.com/):**
Шаг 1. Определить место валидации (конструктор или сеттер)
Что сделать:
Реши, где будет выполняться проверка email — в конструкторе Student и/или в сеттере поля email.
Почему так:Валидация должна происходить в момент присваивания значения, иначе объект может оказаться в некорректном состоянии. Если email задаётся только при создании — достаточно конструктора. Если email можно менять — валидация обязана быть и в сеттере.
Шаг 2. Проверка на null и пустую строку
Что сделать:Добавить проверку, что:строка не null строка не пустая (и лучше — не состоит только из пробелов)
Почему так:Это базовая защита от некорректных данных. Остальные проверки (@, точка) теряют смысл, если строка пустая. Это напрямую соответствует критерию успеха: валидация отклоняет пустые строки.
Шаг 3. Проверка наличия символа @
Что сделать:Убедиться, что в строке есть ровно один @ или как минимум один (на данном этапе достаточно одного).
Почему так:По условию регулярные выражения нельзя использовать, а @ — минимальный признак email. Отсекает строки вроде "example.com" или "testemail". Соответствует критерию: строки без @ отклоняются.
Шаг 4. Проверка точки после символа @
Что сделать:Проверить, что:точка существует она находится после @, а не до
Почему так:Строки вроде "test.@mail" или "test@mail" должны быть отклонены. Проверка порядка символов важнее простой проверки наличия точки. Это минимальная логика, имитирующая структуру local@domain.tld. Соответствует критерию: строки без точки после @ отклоняются.
Итоговая логика (концептуально)
Валидация должна:
Отсекать пустые и null значения
Проверять наличие @
Проверять наличие точки после @
При нарушении — не создавать / не изменять объект (через исключение)
Такой подход:
простой
расширяемый (позже легко заменить на regex)
соответствует требованиям задачи и учебному контексту
Если хочешь, в следующем шаге могу помочь:
проверить твою реализацию логически
или предложить, какое исключение лучше использовать и почему
  **Сравнение:**  
Ответы обоих AI в общей сути схожи.
Одинаково: общая логика валидации, место выполнения валидации, ограничения задачи.
Второй говорит "что делать", 
первый добавляет "как сделать правильно с точки зрения дизайна класса" 
и даёт конкретные технические решения (trim, substring, точные алгоритмы).
Выбор зависит от приоритетов: скорость реализации vs качество архитектуры. 
Первый подход требует немного больше начальных усилий, но создаёт более гибкую и поддерживаемую структуру.
Выбрал AI-1.


#### Промпт 2: Проверка кода
**Код для проверки:**

**Что проверить:**
1. Логические ошибки
2. Соответствие Code Conventions
3. Производительность

**AI-1 [deepseek](https://chat.deepseek.com/):**  
1. ЛОГИЧЕСКИЕ ОШИБКИ И КОРРЕКТНОСТЬ
   Обработка пустого массива: Метод возвращает пустую строку "" при null или пустом массиве. Нужно проверить, соответствует ли это требованиям бизнес-логики (возможно, лучше возвращать "Нет данных" или выбрасывать исключение).
Проверка корректности данных: Нет валидации, что completedLessons <= totalLessons (не может быть пройдено больше уроков, чем всего существует).
Обработка отрицательных значений: Не проверяется, что completedLessons и totalLessons не отрицательные.
2. CODE CONVENTIONS И СТИЛЬ
   Именование переменных: totalTotal — неудачное название (тавтология). Лучше totalAllLessons или просто total.
Форматирование вывода: Жёстко заданный русский текст в методе, который может использоваться в разных контекстах (нарушение принципа интернационализации).
Использование цикла: Можно заменить while на более идиоматичный for или for-each цикл для лучшей читаемости.
Пробелы в конкатенации строк: В строке возврата неравномерные пробелы — нужно проверить единообразие.
3. ПРОИЗВОДИТЕЛЬНОСТЬ И ЭФФЕКТИВНОСТЬ
   Вычисление totalRemaining: Вычисляется правильно, но можно рассмотреть, нужно ли это промежуточное значение как переменную или можно вычислять непосредственно в строке.
Сборка строки: При большом количестве ментаев может быть неэффективной конкатенация строк через +. Рассмотреть StringBuilder для production-кода.
Проверка условий: Условие mentees == null || mentees.length == 0 оптимально, но можно вынести в отдельный метод для читаемости.
Тип данных для счётчиков: int может переполниться при очень большом количестве уроков (маловероятно, но стоит отметить).

**AI-2 [chatGPT](https://chatgpt.com/):**
1. Логические ошибки
Корректность расчёта totalRemaining (нет ли ситуации, когда completed > total)
Поведение при некорректных данных внутри массива (null-элемент, отрицательные значения уроков)
Соответствие возвращаемого результата ожиданиям при null или пустом массиве (пустая строка — осознанное ли решение)
2. Code Conventions (Java)
Имена переменных: читаемость (totalTotal выглядит неудачно)
Использование while vs for (соответствие общепринятому стилю)
Форматирование и пробелы (например, лишний пробел в if (mentees == null || mentees.length == 0 ))
Размещение main-метода (демо-код vs бизнес-логика)
3. Производительность
Линейная сложность O(n) — оптимальна для данной задачи
Отсутствие лишних вычислений внутри цикла
Строковая конкатенация — допустима, т.к. выполняется один раз, а не в цикле
В данном сравнении выбрал AI-2. Более кратко и понятно.



## Quick Start
1. Открыть View → Tool Windows → Gradle.
2. В дереве задач выбрать Tasks → application → run, Tasks → build → build или Tasks → verification → test, запускать двойным кликом.
3. Альтернативно можно использовать Ctrl + Ctrl (Run Anything) и ввести gradle run или gradle test — IDEA выполнит команду без терминала.

## Packages и для чего они нужны

без пакетов два класса с одинаковым именем
столкнутся при импорте, и компилятор не сможет различить их. 
Пакет создаёт уникальную область видимости; 
правило обратного доменного имени 
гарантирует глобальную уникальность, 
так как доменное имя зарегистрировано владельцем.

## Таблица переменных/полей

String menteeName - имя студена.

int sprintNumber - номер спринта.

int plannedHoursPerWeek - запланированное количество часов на спринт в неделю.

public boolean readyForSprint() - метод-ответ "готов ли студент к спринту?", возвращает "true/false(правда ложь)".

## Ссылка на урок
https://mentee-power.xl.ru/learn/MCIneBj4KkyH-GIRCspFvA/tasks


## Git локальный цикл
Проверить интеграцию Git: IntelliJ IDEA → VCS → Enable Version Control Integration → Git. Settings Ctrl+Alt+S → Version Control → Git → указать путь к исполняемому файлу → Test.
Настроить пользователя: в терминале выполнить 
git config --global user.name "Имя Фамилия", 
git config --global user.email "student@example.com". 
Для проверки — git config --list | grep user..
Инициализировать репозиторий и правило веток: 
Project → правый клик по корню → Git → Initialize Repository.
Добавить .gitignore. 

## Правило веток: feature/DVT-X
Создать ветку feature/DVT-Х: 
Git Branches popup → New Branch → feature/DVT-3 → «Checkout». 
Для проверки выполнить git branch --show-current (ожидаем feature/DVT-Х).

## Чек поинты

Remote настроен: git remote -v совпадает с тем, что указано в IDE.

Master опубликован: ветка origin/master показывается в IDE и на GitHub.

PR feature/DVT-3 смёржен: статус merged, ссылка/скрин приложены.

Локальный master синхронизирован: git fetch --all --prune + git pull --ff-only origin master.

Фича‑ветка опубликована: origin/feature/DVT-4 существует; база ветки = origin/master.

PR оформлен: описание + чек‑лист + Evidence Pack; Checks отображаются или задекларированы ручные проверки.


## Чистый Git‑репозиторий

Перед push: git status clean
status clean вводить в терминале.

## Сценарий ручной проверки DVT-7

### Запуск приложения
1. Откройте Gradle Tool Window (View → Tool Windows → Gradle)
2. Выполните: devtools → Tasks → application → run
3. Ожидаемый вывод в Run Tool Window:
   Суммарно: пройдено 25 из 36 уроков, осталось 11 уроков

### Запуск тестов
1. Откройте Gradle Tool Window
2. Выполните: devtools → Tasks → verification → test
3. Ожидаемый вывод: BUILD SUCCESSFUL, все тесты зелёные

### Отладка через Debug
1. Установите breakpoint на строке цикла while в ProgressTracker.calculateProgress
2. Запустите Debug: кликните правой кнопкой на main → Debug 'ProgressTracker.main()'
3. Используйте Step Over (F8) для прохождения итераций
4. Проверьте Variables: counter, remainingHours должны изменяться корректно
5. Используйте Evaluate Expression (Alt+F8): вычислите remainingLessons * 2
6. Ожидаемый результат Evaluate: 14 (для completedLessons=5, totalLessons=12)

### Что делать при ошибках
- Если вывод некорректен: проверьте логику цикла через Debug
- Если тесты красные: откройте вывод теста, найдите AssertionError, скорректируйте метод
- Если Debug не останавливается: убедитесь, что breakpoint установлен (красный кружок)

## Кодстайл-гайд проекта devtools

Проект следует правилам Google Java Style Guide с адаптацией.
Автоматическая проверка: ./gradlew checkstyleMain

### 1. Именование методов: camelCase

До:    public void add_student(Student s) { }
После: public void addStudent(Student student) { }

Почему: Java Convention требует camelCase для методов.
Источник: https://google.github.io/styleguide/javaguide.html#s5.3-camel-case

### 2. Пробелы после if/for/while

До:    if(condition) {
После: if (condition) {

Почему: улучшает читаемость, отделяет ключевое слово от выражения.
Источник: Oracle Code Conventions — Whitespace

### 3. Длина строки: максимум 120 символов

До:    public List getStudentsFromSpecificCityWithVeryLongName...
После: public List getStudentsByCity(String city) {

Почему: длинные строки затрудняют чтение в редакторе и при code review.
Источник: https://google.github.io/styleguide/javaguide.html#s4.4-column-limit

### 4. Порядок импортов

До:    import java.util.List; import java.util.ArrayList; import java.io.File;
После: import java.io.File; import java.util.ArrayList; import java.util.List;

Почему: алфавитный порядок упрощает поиск импортов.
Источник: IntelliJ IDEA → Code → Optimize Imports

### 5. Фигурные скобки для if

До:    if (condition) doSomething();
После: if (condition) { doSomething(); }

Почему: скобки обязательны даже для однострочных блоков.
Источник: https://google.github.io/styleguide/javaguide.html#s4.1.1-braces-always-used

