### Devtools Project


[![Java CI with Checkstyle and JaCoCo](https://github.com/ivental/devtools/actions/workflows/ci.yml/badge.svg)](https://github.com/ivental/devtools/actions/workflows/ci.yml)

## Технологический стек проекта

### Языки и платформы
- **Java 25 LTS** — основной язык разработки
- **Gradle 8.x** — система сборки (через Gradle Wrapper)

### Инструменты качества кода
- **Checkstyle** — статический анализ стиля кода
    - Конфигурация: `config/checkstyle/checkstyle.xml`
    - Запуск: `./gradlew checkstyleMain`
- **JUnit 5** — фреймворк тестирования
    - Запуск: `./gradlew test`

### CI/CD
- **GitHub Actions** — автоматическая проверка PR
    - Checkstyle на каждый коммит
    - Тесты на каждый коммит
    - Конфигурация: `.github/workflows/`

### Правила кода
- Стиль: Google Java Style Guide (через Checkstyle)
- Коммиты: Conventional Commits (`feat:`, `fix:`, `docs:`)
- Ветки: `feature/DVT-X` для задач, `master` — основная
- Pull Request: обязателен для слияния в master


## Code Review Checklist

Используйте этот чеклист для само-ревью перед запросом ревью у ментора:

### Функциональность
- [ ] Код решает поставленную задачу полностью
- [ ] Обработаны граничные случаи (null, пустые данные, экстремальные значения)
- [ ] Обработка ошибок реализована корректно

### Тесты
- [ ] Добавлены тесты для нового функционала (или обновлены существующие)
- [ ] Все тесты проходят локально: `./gradlew test`
- [ ] Покрыты позитивные и негативные сценарии
- [ ] JaCoCo coverage ≥ 80% для нового кода

### Читаемость и стиль
- [ ] Имена переменных, методов и классов отражают назначение
- [ ] Нет дублирования кода (DRY principle)
- [ ] Checkstyle проходит без ошибок: `./gradlew checkstyleMain`
- [ ] Нет закомментированного кода или отладочного вывода (`System.out.println`)

### Документация
- [ ] README обновлён (если добавлена новая функциональность)
- [ ] Публичные методы имеют JavaDoc (если применимо)
- [ ] Примеры использования актуальны
- [ ] Runbook обновлён (если изменились команды запуска/проверки)

### Производительность и безопасность
- [ ] Нет очевидных проблем производительности
- [ ] Нет хардкода паролей, токенов или конфиденциальных данных

## Примеры Code Review комментариев

### Хорошие комментарии (конструктивные)

**Пример 1:**

**Проблема:** Метод `calculateDiscount` (строка 45) имеет 3 вложенных if-else и 40 строк.
**Почему это важно:** Сложная логика плохо тестируется и тяжело поддерживается.
**Предложение:** Вынести каждое условие в отдельный метод (например, `isEligibleForBonusDiscount()`)
и использовать паттерн Strategy для разных типов скидок.



**Пример 2:**

**Проблема:** Тест `testProcessOrder` (строка 78) проверяет только успешный сценарий.
**Почему это важно:** Не проверена обработка ошибок при недостаточном балансе.
**Предложение:** Добавить тест `testProcessOrder_InsufficientBalance_ThrowsException()`
с использованием `assertThatThrownBy()`.



### Плохие комментарии (неконструктивные)

**Пример 1:**

Этот код ужасен, полностью переписать.


**Почему плохо:** Нет конкретики (что именно плохо), нет предложения (как исправить),
токсичный тон (демотивирует автора).

**Пример 2:**

Здесь лучше использовать Stream API.


**Почему плохо:** Нет объяснения почему лучше, нет примера как переписать,
неясно какую проблему это решает.
## Результат само-ревью

#### 1. Забыт отладочный вывод
**Файл:** src/main/java/ru/mentee/power/devtools/Student.java (строка 19)
**Проблема:** Оставлен `System.out.println("Debug: starting loop")`
**Почему важно:** Отладочный вывод замусоривает логи production-приложения и создаёт впечатление небрежности.
**Исправление:** Удалить строку или заменить на logger (если логирование настроено).

#### 3. Закомментированный код
**Файл:** src/main/java/ru/mentee/power/devtools/Student.java (строки 9-11)
**Проблема:** Закомментированы 3 строки метода, забыл раскоментировать.
**Почему важно:** Закомментированный код создаёт путаницу: непонятно зачем он сохранён и актуален ли.
Если нужна история изменений — она в Git.
**Исправление:** Удалить закомментированный код. Если нужна старая версия — посмотреть в Git History.

## Информационный поиск — результаты DVT-11
### Запросы и источники
| № | Запрос                                | Операторы                                                         | Официальный источник                                                                                                               | Альтернатива                                                                                                     | Статус | Дата проверки |
|---|---------------------------------------|-------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------|--------|---------------|
| 1 | Lombok в Maven Central (Gradle Short) | site:search.maven.org "lombok" OR site:mvnrepository.com "lombok" | https://central.sonatype.com/artifact/org.projectlombok/lombok/1.18.30/overview                                                    | https://mvnrepository.com/artifact/org.projectlombok/lombok/1.18.30                                              | 200 OK | 23.12.2025    |
| 2 | Java Stream API документация          | site:docs.oracle.com "stream api" intitle:api java 21             | https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/stream/Stream.html?spm=a2ty_o01.29997173.0.0.19a25171adJLY2 | https://docs.oracle.com/en/middleware/standalone/coherence/15.1.1/develop-applications/using-repository-api.html | 200 OK | 23.12.2025    |
| 3 | горячие клавиши IntelliJ IDEA         | site:www.jetbrains.com/help "keymap" "intellij idea"              | https://www.jetbrains.com/help/idea/settings-keymap.html                                                                           | https://tproger.ru/digest/ide-hotkeys                                                                            | 200 OK | 23.12.2025    |

### AI-промпты и сравнение ассистентов

#### Промпт 1: План решения
**Задача**: Нужно добавить валидацию email в класс Student  
**Контекст**: Java 25, у меня есть класс Student с полем email (String), проект на Gradle  
**Ограничения**: без использования регулярных выражений на данном этапе, простая проверка наличия @ и точки  
**Что мне нужно от тебя**: план из 3-5 шагов, объяснение "почему именно так", НЕ пиши код — я реализую сам  
**Критерии успеха**: валидация отклоняет пустые строки, строки без @, строки без точки после @  

**AI-1 [deepseek](https://chat.deepseek.com/):**  
План шагов
Определение места для валидации. Создать приватный метод валидации (например, validateEmail(String email)) внутри класса Student. Это обеспечит инкапсуляцию: логика проверки email будет скрыта внутри класса и может быть легко изменена в будущем. Валидацию следует проводить непосредственно перед тем, как email присваивается полю объекта (в сеттере или конструкторе).
Проверка на null и пустую строку. В начале метода validateEmail добавить проверку: если строка равна null или после обрезки пробелов (trim()) она пустая, — выбрасывать исключение (например, IllegalArgumentException). Это соответствует требованию отклонять пустые строки и предотвращает NullPointerException на следующих шагах. Почему trim()? Потому что " " или " user@domain.com " — это практически пустая или некорректно оформленная строка.
Проверка наличия символа '@'. Использовать метод String.indexOf('@'). Если результат равен -1 (символ не найден), выбрасывать исключение. Это самая базовая и обязательная часть синтаксиса email-адреса.
Проверка наличия точки после '@'. Это ключевой шаг, который отличает простую проверку от наивной. Нужно убедиться, что после символа @ в строке есть как минимум одна точка (.). Алгоритм:
Найти индекс символа @ (из шага 3).
Используя метод String.substring(index), получить подстроку, которая начинается после символа @.
В этой подстроке проверить наличие точки с помощью indexOf('.'). Если точка не найдена, значит, в доменной части адреса её нет, и это невалидный email. Почему именно после '@'? Потому что локальная часть адреса (до @) может содержать точки, но для домена (например, domain.com) точка обязательна. Проверка "user.@domain" без этого уточнения пройдёт, хотя является сомнительной.
Интеграция валидации в публичный API класса. Вызвать метод validateEmail:
В сеттере поля email (setEmail): это гарантирует, что любой email, устанавливаемый через сеттер, будет проверен.
В конструкторе(ах) класса, которые принимают email как параметр. Это обеспечит, что объект Student не может быть создан с некорректным email.
Почему в обоих местах? Для сохранения консистентности объекта. Независимо от того, создаётся ли объект или изменяется позже, его поле email всегда будет проходить одну и ту же проверку.
Почему этот план эффективен?
Соответствует ограничениям: Использует только методы String (indexOf, substring, trim), без регулярных выражений.
Выполняет критерии: Корректно отклоняет пустые строки, строки без @ и, что важно, строки, где точка находится только до @ (например, user.@domain или user@domain).
Гибкий и поддерживаемый: Валидация вынесена в отдельный метод. Если в будущем требования усложнятся (добавится проверка на пробелы, длина домена и т.д.), нужно будет изменить только этот метод.
Безопасный: Проверка начинается с null и пустых значений, что предотвращает сбои.
Чётко сообщает об ошибке: Использование IllegalArgumentException с понятным сообщением (например, "Email must not be empty", "Email must contain '@'", "Email must contain a dot in the domain part after '@'") сразу укажет пользователю API на причину проблемы.
Этот план даст вам надёжную базовую валидацию, которую вы сможете легко реализовать и при необходимости расширить.

**AI-2 [chatGPT](https://chatgpt.com/):**
Шаг 1. Определить место валидации (конструктор или сеттер)
Что сделать:
Реши, где будет выполняться проверка email — в конструкторе Student и/или в сеттере поля email.
Почему так:Валидация должна происходить в момент присваивания значения, иначе объект может оказаться в некорректном состоянии. Если email задаётся только при создании — достаточно конструктора. Если email можно менять — валидация обязана быть и в сеттере.
Шаг 2. Проверка на null и пустую строку
Что сделать:Добавить проверку, что:строка не null строка не пустая (и лучше — не состоит только из пробелов)
Почему так:Это базовая защита от некорректных данных. Остальные проверки (@, точка) теряют смысл, если строка пустая. Это напрямую соответствует критерию успеха: валидация отклоняет пустые строки.
Шаг 3. Проверка наличия символа @
Что сделать:Убедиться, что в строке есть ровно один @ или как минимум один (на данном этапе достаточно одного).
Почему так:По условию регулярные выражения нельзя использовать, а @ — минимальный признак email. Отсекает строки вроде "example.com" или "testemail". Соответствует критерию: строки без @ отклоняются.
Шаг 4. Проверка точки после символа @
Что сделать:Проверить, что:точка существует она находится после @, а не до
Почему так:Строки вроде "test.@mail" или "test@mail" должны быть отклонены. Проверка порядка символов важнее простой проверки наличия точки. Это минимальная логика, имитирующая структуру local@domain.tld. Соответствует критерию: строки без точки после @ отклоняются.
Итоговая логика (концептуально)
Валидация должна:
Отсекать пустые и null значения
Проверять наличие @
Проверять наличие точки после @
При нарушении — не создавать / не изменять объект (через исключение)
Такой подход:
простой
расширяемый (позже легко заменить на regex)
соответствует требованиям задачи и учебному контексту
Если хочешь, в следующем шаге могу помочь:
проверить твою реализацию логически
или предложить, какое исключение лучше использовать и почему
  **Сравнение:**  
Ответы обоих AI в общей сути схожи.
Одинаково: общая логика валидации, место выполнения валидации, ограничения задачи.
Второй говорит "что делать", 
первый добавляет "как сделать правильно с точки зрения дизайна класса" 
и даёт конкретные технические решения (trim, substring, точные алгоритмы).
Выбор зависит от приоритетов: скорость реализации vs качество архитектуры. 
Первый подход требует немного больше начальных усилий, но создаёт более гибкую и поддерживаемую структуру.
Выбрал AI-1.


#### Промпт 2: Проверка кода
**Код для проверки:**

**Что проверить:**
1. Логические ошибки
2. Соответствие Code Conventions
3. Производительность

**AI-1 [deepseek](https://chat.deepseek.com/):**  
1. ЛОГИЧЕСКИЕ ОШИБКИ И КОРРЕКТНОСТЬ
   Обработка пустого массива: Метод возвращает пустую строку "" при null или пустом массиве. Нужно проверить, соответствует ли это требованиям бизнес-логики (возможно, лучше возвращать "Нет данных" или выбрасывать исключение).
Проверка корректности данных: Нет валидации, что completedLessons <= totalLessons (не может быть пройдено больше уроков, чем всего существует).
Обработка отрицательных значений: Не проверяется, что completedLessons и totalLessons не отрицательные.
2. CODE CONVENTIONS И СТИЛЬ
   Именование переменных: totalTotal — неудачное название (тавтология). Лучше totalAllLessons или просто total.
Форматирование вывода: Жёстко заданный русский текст в методе, который может использоваться в разных контекстах (нарушение принципа интернационализации).
Использование цикла: Можно заменить while на более идиоматичный for или for-each цикл для лучшей читаемости.
Пробелы в конкатенации строк: В строке возврата неравномерные пробелы — нужно проверить единообразие.
3. ПРОИЗВОДИТЕЛЬНОСТЬ И ЭФФЕКТИВНОСТЬ
   Вычисление totalRemaining: Вычисляется правильно, но можно рассмотреть, нужно ли это промежуточное значение как переменную или можно вычислять непосредственно в строке.
Сборка строки: При большом количестве ментаев может быть неэффективной конкатенация строк через +. Рассмотреть StringBuilder для production-кода.
Проверка условий: Условие mentees == null || mentees.length == 0 оптимально, но можно вынести в отдельный метод для читаемости.
Тип данных для счётчиков: int может переполниться при очень большом количестве уроков (маловероятно, но стоит отметить).

**AI-2 [chatGPT](https://chatgpt.com/):**
1. Логические ошибки
Корректность расчёта totalRemaining (нет ли ситуации, когда completed > total)
Поведение при некорректных данных внутри массива (null-элемент, отрицательные значения уроков)
Соответствие возвращаемого результата ожиданиям при null или пустом массиве (пустая строка — осознанное ли решение)
2. Code Conventions (Java)
Имена переменных: читаемость (totalTotal выглядит неудачно)
Использование while vs for (соответствие общепринятому стилю)
Форматирование и пробелы (например, лишний пробел в if (mentees == null || mentees.length == 0 ))
Размещение main-метода (демо-код vs бизнес-логика)
3. Производительность
Линейная сложность O(n) — оптимальна для данной задачи
Отсутствие лишних вычислений внутри цикла
Строковая конкатенация — допустима, т.к. выполняется один раз, а не в цикле
В данном сравнении выбрал AI-2. Более кратко и понятно.

## Личный глоссарий терминов Dev Tools

### Структура глоссария

Каждый термин содержит:
- **RU / EN** — русское и английское название
- **Определение** — краткое (1-2 предложения) объяснение термина
- **Контекст использования** — где и когда применяется
- **Пример** — конкретное применение в коде/команде/документации
- **Источник** — ссылка на официальную документацию

---

### Категория: Java-экосистема

#### JDK — Java Development Kit

**Определение:** Development environment for building applications using the Java programming language. Includes compiler (javac), archiver (jar), documentation generator (javadoc), and other tools.

**Контекст использования:** JDK необходим для компиляции Java-кода в байт-код и создания исполняемых JAR-файлов. Без JDK невозможно собрать Java-проект.

**Пример:** После установки JDK выполняем `java -version` для проверки версии. В IntelliJ IDEA настраиваем Project SDK: File → Project Structure → Project → SDK → выбираем JDK 25.

**Источник:** https://docs.oracle.com/en/java/javase/21/docs/

#### JRE — Java Runtime Environment
**Определение:** Минимальная реализация виртуальной машины для запуска Java-приложений. Содержит JVM и базовые библиотеки, но не включает инструменты для разработки (компилятор, отладчик).
**Контекст использования:** Используется на production-серверах или пользовательских машинах, где нужно только запускать уже скомпилированные Java-приложения (.jar, .war файлы), а не разрабатывать их.
**Пример:** При установке десктопного приложения, написанного на Java, пользователю устанавливается только JRE. Для запуска приложения используется команда java -jar app.jar.
**Источник:** https://docs.oracle.com/javase/8/docs/technotes/guides/install/jre_install.html

#### JVM — Java Virtual Machine
**Определение:** Абстрактная вычислительная машина, которая исполняет байт-код Java. Обеспечивает кроссплатформенность («напиши один раз – запускай везде») и управление памятью (Garbage Collection).
**Контекст использования:** Является ядром для запуска любого Java-приложения. Разные производители (Oracle, OpenJDK, Amazon Corretto) создают свои реализации JVM с различными оптимизациями.
**Пример:** При запуске команды java MyClass загружается JVM, которая интерпретирует и выполняет байт-код из файла MyClass.class. Параметры JVM задаются флагами, например, -Xmx512m для ограничения памяти.
**Источник:** https://docs.oracle.com/javase/specs/jvms/se21/html/

#### Gradle Wrapper — Gradle Wrapper
**Определение:** Скрипт (gradlew), который при первом запуске автоматически скачивает и использует правильную версию Gradle, указанную в проекте.
**Контекст использования:** Используется для гарантии, что все разработчики и CI/CD-системы используют идентичную версию системы сборки, что исключает ошибки из-за расхождений в версиях.
**Пример:** Вместо глобальной команды gradle build в корне проекта используют ./gradlew build (Linux/Mac) или gradlew.bat build (Windows). Файлы gradlew, gradlew.bat и папка gradle/ добавляются в репозиторий.
**Источник:** https://docs.gradle.org/current/userguide/gradle_wrapper.html

#### Build Tool — Инструмент сборки
**Определение:** Программа, которая автоматизирует процессы компиляции, тестирования, упаковки и развертывания кода, а также управляет зависимостями проекта.
**Контекст использования:** Применяется в любом современном проекте для стандартизации и упрощения жизненного цикла сборки. Избавляет разработчика от ручного управления библиотеками и скриптами.
**Пример:** В Java-экосистеме популярны Maven (pom.xml), Gradle (build.gradle.kts) и Ant. Команда mvn clean install или gradle build выполняет полный цикл сборки проекта.
**Источник:** https://en.wikipedia.org/wiki/Build_automation

#### Dependency — Зависимость
**Определение:** Внешняя библиотека или модуль, который требуется проекту для компиляции и работы. Может быть источником (source), бинарником (binary) или другим артефактом.
**Контекст использования:** Объявляется в конфигурационном файле инструмента сборки (например, dependencies в build.gradle.kts). Позволяет не изобретать велосипед и использовать готовые проверенные решения.
**Пример:** Для работы с HTTP в проекте добавляют зависимость implementation("com.squareup.okhttp3:okhttp:4.12.0"). Инструмент сборки автоматически скачает ее из репозитория (Maven Central).
**Источник:** https://docs.gradle.org/current/userguide/declaring_dependencies.html

#### Artifact — Артефакт
**Определение:** Выходной файл, созданный в процессе сборки проекта: JAR, WAR, EAR архив, документация или любой другой результат работы пайплайна.
**Контекст использования:** Артефакты публикуются в репозиториях (Nexus, Artifactory) для использования другими проектами как зависимости или развертываются на серверах.
**Пример:** После успешного выполнения gradle build в папке build/libs/ создается артефакт myapp-1.0.0.jar. В CI/CD этот артефакт может быть задеплоен или протестирован.
**Источник:** https://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html

### Категория: Инструменты разработки
IDE — Integrated Development Environment
**Определение:** Комплексная программа-редактор, которая объединяет в себе инструменты для написания, отладки, компиляции и управления кодом, а также интеграцию с системами контроля версий.
**Контекст использования:** Основная рабочая среда разработчика. Используется ежедневно для повышения продуктивности благодаря автодополнению, рефакторингу, навигации и визуальной отладке.
**Пример:** IntelliJ IDEA, Eclipse, Visual Studio Code. В IDE открывается проект, пишется код, ставятся breakpoints, запускаются тесты и делаются коммиты через встроенный Git-клиент.
**Источник:** https://www.jetbrains.com/idea/

#### SDK — Software Development Kit
**Определение:** Набор инструментов, библиотек, документации и примеров кода для разработки программного обеспечения под конкретную платформу, фреймворк или язык.
**Контекст использования:** Требуется для начала разработки под определенную технологию. Может включать в себя компиляторы, отладчики, эмуляторы и специфичные API.
**Пример:** Android SDK для создания мобильных приложений, AWS SDK для работы с сервисами Amazon, Java SE Development Kit (JDK) — это тоже SDK для Java.
**Источник:** https://developer.android.com/studio

#### Git — Git
**Определение:** Распределенная система контроля версий, созданная Линусом Торвальдсом. Позволяет отслеживать изменения в коде, создавать ветки, сливать изменения и откатываться к предыдущим состояниям.
**Контекст использования:** Стандарт де-факто для хранения исходного кода любого современного проекта. Используется каждым разработчиком для ежедневной работы с кодом.
**Пример:** git init — создать новый репозиторий, git commit -m "message" — зафиксировать изменения, git push origin main — отправить изменения на удаленный сервер.
**Источник:** https://git-scm.com/doc

#### Repository — Репозиторий
**Определение:** Хранилище данных проекта (кода, истории изменений, метаинформации). Бывает локальным (на машине разработчика) и удаленным (на сервере типа GitHub, GitLab, Bitbucket).
**Контекст использования:** Центральное место для хранения и совместной работы над кодом команды. Все операции git работают с репозиторием.
**Пример:** Локальный репозиторий — это скрытая папка .git в корне проекта. Удаленный репозиторий — это URL, например, https://github.com/user/my-project.git, который добавляется командой git remote add.
**Источник:** https://git-scm.com/book/en/v2/Git-Basics-Getting-a-Git-Repository

#### Commit — Коммит
**Определение:** Отдельный «снимок» (snapshot) состояния проекта в определенный момент времени. Содержит изменения файлов и метаданные: автор, дата, уникальный хэш и сообщение.
**Контекст использования:** Основная единица работы в Git. Используется для фиксации логически завершенных изменений: исправление бага, добавление фичи, рефакторинг.
**Пример:** git commit -m "JIRA-123: Add user login validation". Сообщение должно быть понятным и описывать что и зачем было изменено, а не как.
**Источник:** https://git-scm.com/docs/git-commit

#### Branch — Ветка
**Определение:** Указатель на определенный коммит, позволяющий создавать независимые линии разработки. По умолчанию создается ветка main (или master).
**Контекст использования:** Используется для изоляции новой функциональности (feature/...), исправления багов (hotfix/...), подготовки релиза (release/...) от стабильной основной версии кода.
**Пример:** git checkout -b feature/new-payment-method — создать и переключиться на новую ветку для разработки функционала. git merge feature/new-payment-method — влить изменения обратно в main.
**Источник:** https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell

#### Pull Request (Merge Request) — Пул-реквест
**Определение:** Механизм в платформах (GitHub, GitLab) для предложения изменений из одной ветки в другую. Иницирует процесс обсуждения, проверки (code review) и слияния кода.
**Контекст использования:** Ключевая практика совместной разработки. Используется, когда разработчик завершил задачу в своей ветке и хочет добавить изменения в основную ветку (main, develop).
**Пример:** После git push origin feature/new-payment-method в интерфейсе GitHub создается Pull Request. Коллеги проверяют код, оставляют комментарии, и после апрува происходит слияние (merge).
**Источник:** https://docs.github.com/en/pull-requests

#### Checkstyle — Checkstyle
**Определение:** Статический анализатор кода для Java, который проверяет соответствие кода заданным стандартам оформления и правилам кодирования.
**Контекст использования:** Встраивается в процесс сборки (например, как плагин Gradle/Maven) или в IDE. Используется для поддержания единого стиля кода в команде и выявления потенциальных проблем.
**Пример:** Правило NeedBraces проверяет наличие фигурных скобок у конструкций if, else, for. Checkstyle упадет с ошибкой на код if (debug) log.info("test");, требуя if (debug) { log.info("test"); }.
**Источник:** https://checkstyle.sourceforge.io/

#### Debug — Отладка
**Определение:** Процесс поиска, анализа и устранения причин ошибок (багов) в программе с помощью специальных инструментов.
**Контекст использования:** Применяется, когда приложение ведет себя не так, как ожидается: падает с исключением, выдает неверный результат, зависает и т.д.
**Пример:** В IDE (IntelliJ IDEA) запускается конфигурация в режиме Debug, в коде ставятся breakpoints, после чего можно пошагово выполнять программу, смотреть значения переменных и стек вызовов.
**Источник:** https://www.jetbrains.com/help/idea/debugging-code.html

#### Breakpoint — Точка останова
**Определение:** Искусственно созданная точка в коде, при достижении которой выполнение программы приостанавливается, позволяя разработчику исследовать её состояние.
**Контекст использования:** Ставятся на строки, где нужно начать детальный анализ или проверить значения переменных. Бывают линейные, условные (срабатывают при выполнении условия) и логгирующие (не останавливают выполнение).
**Пример:** В IntelliJ IDEA клик на левом поле напротив номера строки устанавливает красный breakpoint. При запуске в режиме Debug программа остановится на этой строке перед её выполнением.
**Источник:** https://www.jetbrains.com/help/idea/using-breakpoints.html

### Категория: Процессы и практики
#### Code Review — Ревью кода
**Определение:** Систематическая проверка исходного кода одним или несколькими разработчиками, не являющимися авторами изменений, с целью улучшения качества кода и обмена знаниями.
**Контекст использования:** Обязательный этап пайплайна перед слиянием ветки с новой функциональностью или исправлением в основную ветку. Проводится через интерфейс Pull/Merge Request.
**Пример:** Автор создает PR, назначает ревьюверов. Ревьюверы проверяют код на корректность, читаемость, соответствие стандартам, отсутствие уязвимостей. Обсуждение ведется в комментариях к строкам кода.
**Источник:** https://google.github.io/eng-practices/review/reviewer/

#### CI/CD — Continuous Integration / Continuous Delivery (Deployment)
**Определение:** Совокупность практик и инструментов для автоматизации процессов интеграции изменений, сборки, тестирования и развертывания приложений.
**Контекст использования:** CI (Непрерывная интеграция): Автоматическая сборка и тестирование каждого коммита в общем репозитории. CD (Непрерывная доставка/развертывание): Автоматическая подготовка и развертывание каждой успешной сборки в среду (тестовую, стейджинг, прод).
**Пример:** Инструмент Jenkins или GitLab CI. При пуше в ветку develop автоматически запускается пайплайн: build → unit test → integration test → package → deploy to staging.
**Источник:** https://www.redhat.com/en/topics/devops/what-is-ci-cd

#### Runbook — Руководство по эксплуатации
**Определение:** Документация, содержащая четкие пошаговые инструкции для выполнения стандартных операционных задач: развертывание, мониторинг, восстановление после сбоев, масштабирование.
**Контекст использования:** Используется DevOps-инженерами и командами поддержки для рутинных операций или реагирования на инциденты. Цель — сделать процессы повторяемыми и не зависящими от конкретного человека.
**Пример:** Runbook «Развертывание сервиса X в production» содержит: 1) Проверить здоровье кластера K8s, 2) Запустить job kubectl apply -f deployment.yaml, 3) Проверить логи пода на наличие ошибок, 4) Запустить smoke-тесты.
**Источник:** https://en.wikipedia.org/wiki/Runbook

### Вопросы по сложным терминам
#### Вопрос 1 В чем разница между JDK, JRE и JVM?

**Задача:** Понять, что именно нужно установить на компьютер, чтобы начать программировать на Java, и что нужно для запуска готовой программы.

**Контекст:** Изучил определения в Oracle Docs, но до конца не понял назначения. 
В интернете также встречаю JRE и JVM. Не понимаю, это одно и то же или разные вещи, и зачем нужны все три.

**Ограничения:** Уже пытался установить «Java» с официального сайта, но там много вариантов: 
JDK, JRE, Server JRE. Не знаю, какой выбрать для простого обучения.

**Ожидаемый результат:** Четкое понимание:

JDK — это «большой набор» для того, кто пишет программы.

JRE — это «маленький набор» для того, кто только запускает готовые программы.

JVM — это «движок» внутри JRE и JDK, который исполняет код.

**Критерии успеха:** Смогу уверенно сказать: «Чтобы начать писать Java-код в IntelliJ IDEA, мне нужно установить JDK».
Смогу объяснить на пальцах: JVM — это как двигатель в машине, JRE — это вся машина с двигателем, 
а JDK — это машина с двигателем + набор инструментов для ремонта и тюнинга.

---

### Вопрос 2: Что такое коммит (Commit) в Git и зачем он нужен?

**Задача:** Понять, что такое «коммит» на простом языке. 
Почему нельзя просто сохранить файлы, а нужно делать эту специальную команду?

**Контекст:** Делаю git add и git commit, 
но не чувствую разницы между этим и обычным сохранением файла (Ctrl+S). Не понимаю смысла этих «снимков состояния».
**Ограничения:** Пробовал делать коммиты, но пишу в сообщениях что попало: «save», «1», «changes». Не вижу в этом ценности.

**Ожидаемый результат:** Осознать, что коммит — это не просто сохранение, а запись важной вехи в истории проекта с понятным описанием. 
Понять, что это позволяет «путешествовать во времени» по коду и работать в команде.

**Критерии успеха:** Начну писать осмысленные сообщения к коммитам, например: «Добавил вход по логину и паролю» вместо «save».
Смогу объяснить, что git log — это история коммитов, и с помощью git checkout можно «вернуться» к любому коммиту, как к сохранению в игре.
Пойму, что коммит — это упаковка всех измененных файлов в один «пакет» с меткой.

## Quick Start
1. Открыть View → Tool Windows → Gradle.
2. В дереве задач выбрать Tasks → application → run, Tasks → build → build или Tasks → verification → test, запускать двойным кликом.
3. Альтернативно можно использовать Ctrl + Ctrl (Run Anything) и ввести gradle run или gradle test — IDEA выполнит команду без терминала.

## Packages и для чего они нужны

без пакетов два класса с одинаковым именем
столкнутся при импорте, и компилятор не сможет различить их. 
Пакет создаёт уникальную область видимости; 
правило обратного доменного имени 
гарантирует глобальную уникальность, 
так как доменное имя зарегистрировано владельцем.

## Таблица переменных/полей

String menteeName - имя студена.

int sprintNumber - номер спринта.

int plannedHoursPerWeek - запланированное количество часов на спринт в неделю.

public boolean readyForSprint() - метод-ответ "готов ли студент к спринту?", возвращает "true/false(правда ложь)".

## Ссылка на урок
https://mentee-power.xl.ru/learn/MCIneBj4KkyH-GIRCspFvA/tasks


## Git локальный цикл
Проверить интеграцию Git: IntelliJ IDEA → VCS → Enable Version Control Integration → Git. Settings Ctrl+Alt+S → Version Control → Git → указать путь к исполняемому файлу → Test.
Настроить пользователя: в терминале выполнить 
git config --global user.name "Имя Фамилия", 
git config --global user.email "student@example.com". 
Для проверки — git config --list | grep user..
Инициализировать репозиторий и правило веток: 
Project → правый клик по корню → Git → Initialize Repository.
Добавить .gitignore. 

## Правило веток: feature/DVT-X
Создать ветку feature/DVT-Х: 
Git Branches popup → New Branch → feature/DVT-3 → «Checkout». 
Для проверки выполнить git branch --show-current (ожидаем feature/DVT-Х).

## Чек поинты

Remote настроен: git remote -v совпадает с тем, что указано в IDE.

Master опубликован: ветка origin/master показывается в IDE и на GitHub.

PR feature/DVT-3 смёржен: статус merged, ссылка/скрин приложены.

Локальный master синхронизирован: git fetch --all --prune + git pull --ff-only origin master.

Фича‑ветка опубликована: origin/feature/DVT-4 существует; база ветки = origin/master.

PR оформлен: описание + чек‑лист + Evidence Pack; Checks отображаются или задекларированы ручные проверки.


## Чистый Git‑репозиторий

Перед push: git status clean
status clean вводить в терминале.

## Сценарий ручной проверки DVT-7

### Запуск приложения
1. Откройте Gradle Tool Window (View → Tool Windows → Gradle)
2. Выполните: devtools → Tasks → application → run
3. Ожидаемый вывод в Run Tool Window:
   Суммарно: пройдено 25 из 36 уроков, осталось 11 уроков

### Запуск тестов
1. Откройте Gradle Tool Window
2. Выполните: devtools → Tasks → verification → test
3. Ожидаемый вывод: BUILD SUCCESSFUL, все тесты зелёные

### Отладка через Debug
1. Установите breakpoint на строке цикла while в ProgressTracker.calculateProgress
2. Запустите Debug: кликните правой кнопкой на main → Debug 'ProgressTracker.main()'
3. Используйте Step Over (F8) для прохождения итераций
4. Проверьте Variables: counter, remainingHours должны изменяться корректно
5. Используйте Evaluate Expression (Alt+F8): вычислите remainingLessons * 2
6. Ожидаемый результат Evaluate: 14 (для completedLessons=5, totalLessons=12)

### Что делать при ошибках
- Если вывод некорректен: проверьте логику цикла через Debug
- Если тесты красные: откройте вывод теста, найдите AssertionError, скорректируйте метод
- Если Debug не останавливается: убедитесь, что breakpoint установлен (красный кружок)

## Кодстайл-гайд проекта devtools

Проект следует правилам Google Java Style Guide с адаптацией.
Автоматическая проверка: ./gradlew checkstyleMain

### 1. Именование методов: camelCase

До:    public void add_student(Student s) { }
После: public void addStudent(Student student) { }

Почему: Java Convention требует camelCase для методов.
Источник: https://google.github.io/styleguide/javaguide.html#s5.3-camel-case

### 2. Пробелы после if/for/while

До:    if(condition) {
После: if (condition) {

Почему: улучшает читаемость, отделяет ключевое слово от выражения.
Источник: Oracle Code Conventions — Whitespace

### 3. Длина строки: максимум 120 символов

До:    public List getStudentsFromSpecificCityWithVeryLongName...
После: public List getStudentsByCity(String city) {

Почему: длинные строки затрудняют чтение в редакторе и при code review.
Источник: https://google.github.io/styleguide/javaguide.html#s4.4-column-limit

### 4. Порядок импортов

До:    import java.util.List; import java.util.ArrayList; import java.io.File;
После: import java.io.File; import java.util.ArrayList; import java.util.List;

Почему: алфавитный порядок упрощает поиск импортов.
Источник: IntelliJ IDEA → Code → Optimize Imports

### 5. Фигурные скобки для if

До:    if (condition) doSomething();
После: if (condition) { doSomething(); }

Почему: скобки обязательны даже для однострочных блоков.
Источник: https://google.github.io/styleguide/javaguide.html#s4.1.1-braces-always-used

